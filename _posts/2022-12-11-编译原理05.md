---
layout: post
title: 编译原理05
date: 2022-12-10 17:57 +0800
last_modified_at: 2022-12-10 18:11 +0800
tags: [Notes]
toc:  true
math: true
---

自底向上的语法分析
{: message}

> 这一章节内容很多，需要参照教案学习

## Overview总览

前面我们学过自顶向下的语法分析，并在其基础上研究了LL(1)文法和LL(1)分析。自顶向下的语法分析在形式语言上对应**推导**，即如何从开始符S推出所给字串。本节我们研究自底向上的语法分析，对应形式语言的**规约**过程，即从所给字串归约到开始符S。

### 概念引入

本节新引入如下概念：

- 可规约串，不可规约串
- 短语，直接短语（直接短语对应的就是可规约串）
- 句柄，右句型

> 学习借助语法分析树求短语、直接短语、句柄

这些概念的逻辑是：可规约串是所给句型中可以进行规约的选择，但是一个句型中可以有多个可规约串，于是产生了规约过程的不确定性。为了消除不确定性，我们引入了短语、直接短语、句柄的概念。直到句柄，对应了句型中最小的、最右的一步规约。在规约过程中，每次总是选择句柄进行规约，这样就消除了不确定性。

除此之外还引入概念：

- 增广文法
- 活前缀
- **移进-规约冲突**，**规约-规约冲突**

## 移进-规约分析（LR分析）

### 基于给定的 LR 分析表分析

LR 分析的流程：

1. 获得状态转移图
2. 获得 LR 分析表
3. 用 LR 分析表进行分析

其中，状态转移图和 LR 分析表的构造过程取决于所用的 LR 分析方法（后面介绍的LR(0),SLR(1),LR(1),LALR(1)等）。而当获得了状态转移图和 LR 分析表后，分析过程对于不同的 LR 分析方法是一样的，如下：

<a href="https://sm.ms/image/DhAzqX2oUIrFKyN" target="_blank"><img src="https://s2.loli.net/2022/12/11/DhAzqX2oUIrFKyN.png" width=600></a>

> 分析过程可以归为四类操作：Shift，Reduce，Error，Accept。记住这四种操作是如何执行的就可以。

> 不同的 LR 分析方法通过不同的算法构造相同结构的 LR 分析表，采用相同的 LR 分析过程。LR 分析表的结构示例如下：
> <a href="https://sm.ms/image/XZlsqDmFB9RQcI8" target="_blank"><img src="https://s2.loli.net/2022/12/11/XZlsqDmFB9RQcI8.png" width=300></a>

### LR(0) 分析

首先学习：
1. LR(0) 项目的概念
2. CLOSURE(I) 和 GO(I,X)=CLOSURE(J) 是怎么定义和计算的

LR(0) 状态转移图的每一个状态对应的是某组LR(0)项目集合的闭包，每一条转移对应一条GO()函数

核心算法：
- 给定文法G(S)，计算其状态转移图
    1. 构造增广文法
    2. 初始状态
    3. 不断按照 GO 函数规则找新状态和状态转移
- 由状态转移图构造 LR 分析表（算法见教案）

LR(0)文法判断两种方法：
- 状态转移图的所有状态，没有一个状态里面发生移进-规约冲突或规约-规约冲突
- LR分析表中表项不存在多重定义

### SLR(1) 分析

只有满足LR(0)文法条件的G(S)，才可以使用LR(0)分析，但是满足LR(0)文法条件的文法不多。相比而言，SLR(1)分析比LR(0)分析适用范围更广一些。

SLR(1) 分析的算法见教案，相比于LR(0)分析，算法一直到生成状态转移图为止都是一样的，在最后一步根据状态转移图生成LR分析表的环节，对于 r 项的处理与LR(0)分析不一样。

SLR(1) 算法的核心是借助要规约的非终结符的 Follow 集合解决冲突问题，具体来说：
- 如果每一状态的所有归约项中要归约的非终结符的 Follow 集互不相交， 则可以解决归约−归约冲突。
- 如果每一状态的所有归约项中要归约的非终结符的 Follow 集与该状态所有移进项目要移进的符号集互不相交，则可以解决移进−归约冲突

### LR(1) 分析

SLR(1) 解决冲突的两点中，如果存在交集，那么就违背了SLR(1)文法规则，也就不能使用SLR(1)分析了。LR(1)比SLR(1)的应用范围更广一些。

首先学习：
- LR(1)项目
- 向前搜索符（其含义）
- 终止符 #
- CLOSURE(I) 和 GO(I,X)=CLOSURE(J) 的定义和计算

LR(1) 的算法见教案

LR(1)文法判断的两种方法：
- LR分析表没有多重定义
- 可以通过 LR(1) 有限状态机直接判断相应的文法是否 LR(1) 的。 文法 G 是 LR(1) 文法，当且仅当它的 LR(1) 有限状态机中的每个状态都满足：
    1. 如果该状态含有项目 $[A\rightarrow \alpha.a\beta, b]$ （a 为终结符）， 那么就不会有项目$[B\rightarrow \gamma., a]$；反之亦然。这表明该状态不存在移进-归约冲突。
    2. 该状态中的所有归约项目的向前搜索符互不相交，即不同时含有项目 $[A\rightarrow \alpha., a]$和 $[B\rightarrow \beta., a]$。这表明该状态不存在归约-归约冲突。

### LALR(1) 分析

LALR(1) 分析是 LR(1) 分析的一个简化版，分析能力弱于LR(1)。简化的核心思想就是合并**同芯状态**

学习：
- 芯的概念
- 同芯状态合并的方式

> 对于LR(1)分析状态转移图的同芯状态合并不会产生新的移进-归约冲突，但是可能会产生新的归约-归约冲突。




