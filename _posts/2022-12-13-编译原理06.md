---
layout: post
title: 编译原理06
date: 2022-12-10 17:57 +0800
last_modified_at: 2022-12-10 18:11 +0800
tags: [Notes]
toc:  true
math: true
---

语法制导的语义计算
{: message}

## 引言

前面我们完成了词法分析和语法分析，其中，通过词法分析，我们将程序代码的字符流转换为了一个个的单词，通过语法分析，判断了所给的单词序列是否符合语言所规定的语法规则，并且如果符合的话给出了语法分析树。但是只有这些就够了吗？我们来看这样一个例子：

```c++
int main(){
    int a = 1;
    b += a;
    return 0;
}
```

如果只是进行词法分析和语法分析的话，上面这段程序我们认为是符合词法语法规则的。但是这段程序显然是无法编译的，因为变量```b```使用前没有定义。所以，仅仅进行词法分析和语法分析是不够的，上面的例子反映出词法分析和语法分析的一个重要不足：**词法分析和语法分析不能结合上下文进行语义信息的检查**。所以，我们需要在语法分析的基础上进行**语义分析**，或者说进行**语义计算**。

## 属性文法

**上下文无关文法+属性+语义动作=属性文法**

### 属性

首先我们需要解决一个问题：**如何记录或者说传递上下文信息？** 为了解决这个问题，我们引入**属性**的概念。其实在前面词法分析中，我们已经使用过属性的概念。我们用一个二元组```<token,value>```来唯一地标识一个单词，这里的```token```和```value```就可以看作是属性。在语义计算中，我们需要扩展属性的概念，使得属性不仅仅是一个值，而是一个**属性集合**。这个属性集合可以包含多个属性，每个属性都有一个名字，这样我们就可以通过属性名来访问属性值。

### 语义动作

同样为了解决 **如何记录或者说传递上下文信息** 的问题，我们引入**语义动作**的概念。语义规则与产生式关联，形式如```A -> a  {action}```。其中action段就是语义动作，它的作用是描述这条产生式执行的同时，涉及的文法符号的属性值之间的计算关系。比如我们给出这样的例子：

```
A -> a + b {A.val = a.val + c.val}
B -> C D {C.parent = B} {D.parent = B}
```

在语义分析中，基于语义动作，我们进一步将属性细化，分为**继承属性**和**综合属性**。对于关联于产生式```A -> a```的语义动作```b=func(c_1,c_2....)```，如果 b 是产生式左部 A 的属性，则 b 为 A 的一个综合属性。如果 b 是产生式右部某一文法符号的属性，则 b 为 A 的一个继承属性。从我们的定义中，我们可以看出，继承属性是由产生式右部的文法符号的属性和左部文法符号的继承属性计算得到的，所以反映的是一个自顶向下的属性值传递，而综合属性是由产生式右部的文法符号的属性计算得到的，所以反映的是一个自底向上的属性值传递。

> 找出所给文法的所有继承属性和综合属性：遍历文法的所有产生式，逐个属性判断。

### 分析树遍历等语义计算

**属性文法参与到语义分析的过程，最终的目的是求出语法分析树上所有结点的所有属性值，这个过程叫做语义计算**。语法分析树遍历是一种最简单的实现语义计算的算法。

算法包含以下几步：

1. 构造依赖图：首先拿到语法分析树。按照语法分析树的结构，构造一个依赖图，图中的结点是语法分析树的结点，图中的边是语义动作的依赖关系。比如上面的例子中，```A -> a + c {A.val = a.val + c.val}```，我们可以看出，A.val的计算依赖于```a.val```和```c.val```，所以我们可以构造出一个依赖图，其中```A.val```的结点依赖于```a.val```和```c.val```的结点，即```a.val```和```c.val```出发两条有向边指向```A.val```的结点。
2. 对依赖图检查是否是无环图，若是，则进行拓扑排序
3. 按照拓扑排序依次计算每个属性结点的值

> 有一些语义动作需要配置虚结点，比如```S -> A {print(A.value)}```，按照前面的规则，这里有一条从```A.value```出发的边，但是没有终点。此时需要将```print(A.value)```作为一个虚结点，将其作为终点。

### S属性文法和L属性文法

如果一个属性文法中只包含综合属性，那么这个属性文法就是一个**S属性文法**。对于这样的文法，其语义计算过程可以简化为：**自底向上遍历语法分析树**，计算每个结点的综合属性。

如果一个属性文法中所有的继承属性都满足：
- 对于所有的产生式```A -> X_1 X_2 ...```，其中```X_i```的继承属性只能依赖于```X_1```、```X_2```、...、```X_{i-1}```的属性和```A```的继承属性

则该属性文法就是一个**L属性文法**。对于这样的文法，其语义计算过程可以简化为：从叶子结点开始，按照**深度优先遍历**的顺序遍历语法树，计算每个结点的属性。

## 翻译模式

我们说过，使用属性文法进行语义分析的核心就是**语义计算**。虽然分析树遍历是一种简单的语义计算算法，但是它的效率并不高。因此，我们需要一种更高效的语义计算算法。这种算法就是**翻译模式**。

之所以声称翻译模式执行语义计算的效率高，是因为**翻译模式的语义计算可以与语法分析过程并行执行**（这一点下面我们就可以看到）。这样，语义计算的效率就可以得到提高。

### 翻译模式的基本思想

翻译模式在属性文法的基础上，允许动作语义出现在产生式右部的任何位置，并以此来表示执行动作语义的时机和顺序。下面给出一个简单的例子：

```
A -> {B.parent = A} B {print(B.value)} {C.parent = A} C {print(C.value)} {D.parent = A} D {print(D.value)}
```

### S-翻译模式

S翻译模式就是S属性文法的翻译模式。由于S属性文法只涉及综合属性，因此S翻译模式中的动作语义只能出现在产生式右部的最后一个符号的后面。从这个意义上看，S翻译模式形式上和S属性文法是一样的。

前面说过，S属性文法可以使用自底向上的方式进行语义计算，因此S翻译模式也可以使用自底向上的方式进行语义计算，具体地需要在语法分析的基础上增加维护一个存放属性值的语义栈，在每次规约的时候执行动作语义，并将动作语义的结果压入语义栈。

基于这种语义栈的思想，我们可以对S-翻译模式中的产生式做相应的产生式变换，使其适应基于语义栈的语义计算。下面给出一个例子：

<a href="https://sm.ms/image/o7HuZBOTAalnIK1" target="_blank"><img src="https://s2.loli.net/2022/12/17/o7HuZBOTAalnIK1.png" width=400></a>

可以看出，这种语义计算可以与语法分析并行执行。

### L-翻译模式

L翻译模式在L属性文法的基础上，要求：

- 产生式右端某个符号继承属性的计算必须位于该符号之前，其语义动作不访问位于它右边符号的属性，只依赖于该语义动作左边符号的属性 （对于产生式左部的符号，只能是继承属性）
- 产生式左部非终结符的综合属性的计算只能在所用到的属性都已计算出来之后进行，通常将相应的语义动作置于产生式的尾部

基于 L-翻译模式，我们有两种语义计算的方法：

- 自顶向下，与自顶向下的语法分析同时完成
- 自底向上，与自底向上的语法分析同时完成

#### 自顶向下的L-翻译模式语义计算

前面我们研究过自顶向下的语法分析，并且给出了代码实现的算法。我们只需要在这个语法分析代码的基础上进行微小改动即可完成L-翻译模式的自顶向下的语法计算，如下图所示：

<a href="https://sm.ms/image/tAI52hQWmR7V3pB" target="_blank"><img src="https://s2.loli.net/2022/12/17/tAI52hQWmR7V3pB.png" width=500></a>

#### 自底向上的L-翻译模式语义计算

自底向上的L-翻译模式语义计算稍显复杂，我们一点一点理解其思路。

首先，自底向上的语义计算就是使用语义栈的算法。语义栈上只存储综合属性，因此对于语义计算过程有以下要求：

- 继承属性的求值结果需要以某个综合属性的值存在语义栈中
- 对于继承属性的访问也要最终落实到对于某个综合属性的访问

来看这个例子：

```
S -> A {print(A)} B {print(B)}
```

我们可以做如下变换，通过引入空串产生式，使得动作语义全部挪到产生式末尾：

```
S -> AMBN
M -> \epsilon {print(A)}
N -> \epsilon {print(B)}
```

然后看这个例子：

```
S -> A {C.i=A.i} C {S.i=A.i+C.i}
```

这里面显然 A.i 是 A 的综合属性，在语义栈上。C.i 的值可以通过从语义栈上获得 A.i 的值来计算得到，进一步在计算 S.i 的时候，C.i 虽然作为继承属性不在语义栈上，但是我们前面知道 C.i 继承自 A.i，因而可以直接通过 ```S.i=A.i+A.i```的方式计算得到。

然后看这个例子：

```
S -> A {C.i=f(A.i)} C {S.i=A.i+C.i}
```

这里有一个问题，在计算 C.i 的时候，A.i 在语法栈上，但是 f(A.i) 却不在语法栈上。我们需要一种方法，使得在计算 C.i 的时候，f(A.i) 也在语法栈上。我们可以通过如下变换：

```
S -> A {M.s=A.i} M {C.i= M.i} C {S.i=A.i+C.i}
M -> \epsilon {M.i=f(M.s)}
```

通过这个变换，使得 f(A.i) 借助于综合属性 M.i 得到了进入语法栈的机会。

然后再看这个例子：

```
S -> A {C.s=A.i} C
S -> A B {C.s=A.i} C
C -> c {C.i=f(C.s)}
```

这里有一个问题，在计算 C.i 的时候，C.s 的值是什么，是 v[top-1]，还是 v[top-2]呢(v 是语义栈)？这个问题需要解决。我们做如下变换：

```
S -> A {C.s=A.i} C
S -> A B {M.s=A.i} M {C.s=M.i} C
C -> c {C.i=f(C.s)}
M -> \epsilon {M.i=M.s}
```

通过这样一个变换，我们用一个新构造的综合属性 M,i 解决了问题，C.s 的值就是 v[top-1]，而不是 v[top-2]。

> 总结一下，我们本小节一共介绍了三种文法变换的方法。