---
layout: post
title: 编译原理03
date: 2022-12-09 17:57 +0800
last_modified_at: 2022-12-09 18:11 +0800
tags: [Notes]
toc:  true
math: true
---

自顶向下的语法分析
{: message}

## 语法分析概念

给定一个文法G[S]和一个字符串w，语法分析的目的是判断w是否属于G[S]的语言，如果属于，还要找出w的一个语法分析树。我们要研究语法分析的原因是，代码语言的语法规范是由文法来描述的，所以对于输入的代码字符串，我们需要判断它是否符合语法规范，如果不符合，就需要报错，如果符合，就需要生成语法分析树，语法分析树是后续语义分析和代码生成的基础。

## 自顶向下的语法分析

对于文法G[S]，判断字符串w是否是属于G[S]的语言的一种方法是，从G[S]的开始符号S出发，如果依据G[S]的文法规则可以推出w，那么w就是G[S]的语言，否则w就不是G[S]的语言。这种方法就是自顶向下的语法分析。

## 自顶向下的语法分析的实现

### 带回溯的自顶向下的语法分析

带回溯的自顶向下的语法分析的实现方法是，从G[S]的开始符号S出发，依据G[S]的文法规则，逐步推导出w，如果推导过程中出现了不符合文法规则的情况，就回溯到上一步，尝试其他的文法规则，直到推导出w为止。可以理解，这种方法的复杂度是很高的，不适合程序实现。

> 这里的复杂度来自两个方面：
> 1.推导的每一步选择哪一个非终结符
> 2.对于选择的非终结符调用其的哪一个产生式
> 虽然使用最左推导或者最右推导可以消除第一个复杂度，但是第二个复杂度仍然存在而且影响很大。

如果我们的文法规则可以在源头上同时消除这两个复杂度，那么我们得到的是**确定的自顶向下的语法分析算法**。

### 自顶向下预测分析

如果我们规定了最左推导（因为代码字符流一般是自左向右读入的），为了消除第二类复杂度，可以采用**向前查看 n 个字符**的策略，即在推导过程中，每次选择一个非终结符，都要向前查看 n 个字符，然后根据这 n 个字符来选择调用哪一个产生式。这种方法就是自顶向下预测分析。

> 显然不是所有的文法规则下都可以使用这种方法，有些文法无论向前查看多少个字符都无法进行预测。另外，这种方法的 n 的取值也是有限制的，如果 n 太大，那么就会导致向前查看的字符过多，从而导致语法分析的效率降低。

接下来我们介绍的**LL(1)文法**就是一种可以使用自顶向下预测分析的文法，并且 n 的取值为 1。

### LL(1)文法

**LL(1)分析**即向前查看一个字符的自顶向下预测分析。LL(1)分析的前提是文法必须是**LL(1)文法**。因此我们首先要关注的是如何判断一个文法是否是LL(1)文法，这个判断主要借助于**FIRST集合**和**FOLLOW集合**的概念。

#### First集合

首先看 first 集合的形式化定义：

![first集合.png](https://s2.loli.net/2022/12/10/DjPvwUmugkK3qF8.png)

对于这个定义，有一种更直观的解释：

- 一个句型 $$\alpha$$ 若可以推导出另一个**以终结符 a 开头**的句型，那么 a 属于 First（$$\alpha$$）；若 $$\alpha$$ 可以推导出 ε，那么 ε 也属于 First（$$\alpha$$）。

> 由于句型 $$\alpha \in (V_N \cup V_T)^*$$，所以上面的定义也同时包含了单个终结符和非终结符的 First 集合的定义

#### Follow集合

首先看 follow 集合的定义：

![follow集合.png](https://s2.loli.net/2022/12/10/jaIXRBKQD4eEHJN.png)

对于这个定义，有一种更直观的解释：

- 根据文法规则，从 S 出发推导出来的句型里面，如果有句型包含 Xa 子串，则 a $$\in$$ Follow(X)，如果有以 X 结尾的句型，则 # $$\in$$ Follow(X)

> 注意根据定义，我们只关心非终结符的 Follow 集合

#### 预测集合（PS）

直接来看定义：

![PS集合.png](https://s2.loli.net/2022/12/10/91SdFWRjbHOuV6z.png)

#### LL(1) 文法判定

当且仅当文法 G 中任意两个具有相同左部的不同产生式 $$A\rightarrow \alpha$$ 和 $$A\rightarrow \beta$$ 都满足 $$PS(A\rightarrow \alpha) \cap PS(A\rightarrow \beta) = \phi$$，文法 G 为 LL(1) 文法

### LL(1)分析

LL(1) 分析主要有两种实现方式，看教案

## 文法变换

有时候拿到的文法 G 不是 LL(1) 的，但是可以通过适当的文法变换，转换成期望的文法类型。这里介绍两种文法变换方式：

- 消除左递归
- 提取左公因子

> 因为 LL(1) 是对于最左推导的要求，所以上面两个文法变换都着眼在 “左”

### 消除左递归

若文法 G 中有一组形如 $$P\rightarrow P_1\alpha_0$$，$$P_1\rightarrow P_2\alpha_1$$，$$P_2\rightarrow P_3\alpha_2$$ ... $$P_n\rightarrow P\alpha_n$$ 的产生式，则称该文法是左递归的。进一步的如果有 $$n=0$$ 则称直接左递归，$$n>0$$ 则称间接左递归。

消除直接左递归的方法：

![直接左递归.png](https://s2.loli.net/2022/12/10/A32gfwK4CqeBjGO.png)

消除一般左递归的方法更为复杂：

![间接左递归.png](https://s2.loli.net/2022/12/10/VrSlxZJX2TjocbD.png)

### 提取左公因子

![提取左公因子.png](https://s2.loli.net/2022/12/10/9eIwDH6aKodXhLg.png)