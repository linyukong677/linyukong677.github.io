---
layout: post
title: 编译原理02
date: 2022-12-09 13:57 +0800
last_modified_at: 2022-12-09 17:11 +0800
tags: [Notes]
toc:  true
math: true
---

词法分析
{: .message }

## 词法分析概念

词法分析是编译过程的第一步。我们先在大脑里想象一下，编译器如何处理我们的代码使之称为可以被计算机理解和执行的语言。我们的代码是由一系列的字符组成的并存储在计算机中。比如一段代码```int a = 1;```，编译器首先需要知道如何进行划分，是```int|a|=|1|;```，还是```in|ta|=|1|;```等等。因此编译器首先要做的就是将这些字符分割成一个个的单词，分割的规则满足我们对于代码规则的定义，使得分割出来的单词都是代码的**基本单元**，这个过程就是**词法分析**。

前面是我们抽象的思考，下面我们用术语将其描述出来。前面我们说的**基本单元**，术语叫做**单词记录**，它可以表示成形如```<token, value>```的这样一个二元组，其中，```token```叫做**单词符号**，```value```叫做**属性值**。

> 在程序设计语言中，单词的种类一般可以分为：关键字、标识符、常数、运算符、界符等。比如```int```是关键字，```a```是标识符，```1```是常数，```=```是运算符，```;```是界符。代码```int a = 1;```里面的单词```a```的单词符号```token=identifier```。但是如果同时存在```int a = 1;```和```int b = 2;```的话，```a```和```b```的```token```都是标识符类型，如何区分呢，这就是为什么我们需要属性值```value```。对于```a```其产生的单词记录为```<token=identifier, value=a>```，对于```b```其单词记录为```<token=identifier, value=b>```

总结一下单词符号可以取值的范围是（只是枚举，不同的语言单词符号不同）：
- 关键字：if, else, while, int, ....
- 标识符 identifier
- 常数 constant
- 运算符：+，-，*，/，=，<，>，<=，>=，==，!=，&&，||，!
- 界符：(，)，{，}，[，]，;，,

其中不同的标识符和不同的常数需要额外的属性值来区分，因为它们的单词符号都是相同的。对于标识符，我们可以用它的名字来区分，比如```value=a```和```value=b```，对于常数，我们可以用它的值来区分，比如```value=1```和```value=2```。

词法分析过程的主要目的是从字符流中提取出单词记录，除此之外，词法分析还可以执行一些额外的工作，比如去除注释、去除空白符、符号表维护、检查单词符号是否合法（比如```int 1a = 1;```中```1a```的命名方式就不合法）等等。

> 符号表的维护是一个较为复杂的过程，可以在词法分析的过程中完成，也可以在语法分析的过程中完成。这里我们暂时不做过多的讨论，只是简单的提一下。

## 词法分析的实现

词法分析的实现过程可以分为两部分：
1. 词法规则设计
2. 词法分析程序设计

### 词法规则设计

词法规则设计要求将词法规则描述成形式化或半形式化的描述，比如正则表达式，EBNF，有限状态机等等，从而方便后续的词法分析程序的设计。

下面我们给一个PL/0语言词法规则的EBNF描述，可以作为参考：

![PL0_EBNF.png](https://s2.loli.net/2022/12/09/iPXk5R3aLbsFxM8.png)

### 词法分析程序设计

有了形式化或半形式化的词法规则，我们就可以设计相应的分析程序，主要借助 NFA 和 DFA 技术。这一部分涉及 FLA 的知识，即给定一个比如正则表达式，利用构造法构造对应的 epsilon-NFA，甚至将其转换成等价 DFA，甚至更进一步转换成基于 TABLE 的 DFA。

得到自动机之后我们就可以设计程序扫描字符流并模拟自动机运行来进行词法分析。

> 字符退还：
> 扫描字符流的时候可能会遇到**字符退还**问题。具体来说，```<```和```<=```，当扫描到```<```时，必须再多往下扫描一个字符才能确定是```<```还是```<=```。如果不是```<=```，比如是```a<b```这种情形，那么需要将多扫描的```b```字符吐出来，这个过程叫做字符退还

