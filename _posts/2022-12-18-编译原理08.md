---
layout: post
title: 编译原理08
date: 2022-12-10 17:57 +0800
last_modified_at: 2022-12-10 18:11 +0800
tags: [Notes]
toc:  true
math: true
---

运行时存储组织
{: message}

## 引言

运行时存储组织是指程序在运行时所占用的存储空间的组织方式，其主要包含以下研究内容：

- 数据对象表示
- 表达式计算
- 存储分配策略
- 活动记录

其中，数据对象的表示包括数据的占用字节数（大小）、大小端、对齐方式等等；表达式计算主要研究表达式求值过程的临时量和计算结果的记录存储方式，比如专用的运算数栈等。存储分配策略包含静态、动态内存分配，栈、堆等内容；活动记录主要研究函数调用和块代码等的栈帧结构。

本节的重点在于存储分配策略和活动记录。

## 存储分配策略

首先来看运行时的整体的存储空间布局

<a href="https://sm.ms/image/jSOmMiN5ZduVIgz" target="_blank"><img src="https://s2.loli.net/2022/12/18/jSOmMiN5ZduVIgz.png" width=400></a>

需要注意，上图展示的是一般的存储空间布局，实际的存储空间布局与目标机器的体系结构和操作系统密切相关。这也是为什么采取**基址+偏移量**的虚拟内存的方式维护运行时存储，使得其可以在目标机器的任意一段内存中运行。

在上面的布局中，我们所关心的数据区是**静态数据区**+**栈空间**+**堆空间**，对应的各个数据区的存储分配策略为：静态存储分配，栈式动态存储分配，堆式动态存储分配。

### 静态存储分配

如果有一些数据对象我们在编译阶段就可以知道其大小和数目，那么我们就可以将其放在**静态数据区**。比如我们熟知的全局变量、静态变量、程序中的常量和 class 的虚函数列表，都可以放在这个区域。

> 静态数据区存储和分配简单，但是静态分配的内存相当于是被一个数据对象独占了，这其实会带来存储空间的浪费，这也是我们为什么不将更多的数据放在静态存储区的原因。

### 栈式动态存储分配

> 与后面的堆式存储分配一样，这两种都是**动态存储分配**策略，即一段内存不会被一个数据对象独占，而是被数据对象在某一时期占有。这样可以提高内存空间的复用效率。

栈区是作为“栈”这样一种数据结构来使用的动态存储区，我们称之为运行栈（run-time stack）。 运行栈数据空间的存储和管理方式称为栈式存储分配，它将数据对象的运行时存储按照栈的方式来管理， 常用于有效实现可动态嵌套的程序结构， 如过程、 函数以及嵌套程序块（分程序），并在运行栈中通过活动记录的入栈出栈进行嵌套维护。

> 在编译期间，活动记录的大小(最大值)能够确定，这是进行栈式存储分配的必要条件。否则需要用堆式存储分配。

### 堆式动态存储分配

当数据对象的生存期与创建它的过程/函数的执行期无关时，例如某些数据对象可能在该过程/函数结束之后仍然长期存在，就不适合进行栈式存储分配。 一种灵活但是较昂贵的存储分配方法是堆式存储分配。 在堆式存储分配中， 可以在任意时刻以任意次序从数据段的堆区分配和释放数据对象的运行时存储空间

> 但是要注意，堆式分配的存储需要动态地分配和释放，这样会带来一些额外的开销，比如分配和释放的时间开销，以及分配和释放的空间开销。

由于堆上的内存分配是灵活自由的，所以会导致出现内存碎片，这样会导致内存的浪费。因而需要一些内存分配优化原则，比如：

- 最佳适应
- 最先适应
- 循环最先适应

## 活动记录

活动记录是栈式存储分配的基本单位，本节我们深入研究一下活动记录。首先我们将研究最基本的**过程/函数运行时的活动记录的典型结构**，然后会研究**嵌套过程非局部变量访问在活动记录上的实现**，最后研究**嵌套块非局部变量访问在活动记录上的实现**。

> 第一种典型结构是活动记录的基本结构，第二种第三种是活动记录的扩展结构，因为不是所有语言都支持嵌套过程和嵌套块。

### 过程/函数运行时的活动记录的典型结构

活动记录的典型结构如下：

<a href="https://sm.ms/image/3LTqJPDfaOuvMeC" target="_blank"><img src="https://s2.loli.net/2022/12/18/3LTqJPDfaOuvMeC.png" width=300></a>

其中，控制信息区存储的，是这个活动记录与其他活动记录的联系，包括返回地址、静态链(后面会介绍)、动态链(后面会介绍)等等。过程/函数实际参数区存储的是调用传进来的参数(很多体系下，传参依赖或使用栈帧)。固定大小的局部数据区存储的是被调用的过程/函数的，大小确定的局部变量。动态数组区存储的是被调用的过程/函数中的长度、大小不确定的数组。临时工作单元是用来做临时变量的存储的(比如运算等涉及的中间量)。

下面看两个例子：

<a href="https://sm.ms/image/vqW9TOiYog6rRQ3" target="_blank"><img src="https://s2.loli.net/2022/12/18/vqW9TOiYog6rRQ3.png" width=400></a>

<a href="https://sm.ms/image/pXEsA1DSkONql87" target="_blank"><img src="https://s2.loli.net/2022/12/18/pXEsA1DSkONql87.png" width=400></a>

### 嵌套过程/函数的非局部变量访问

请看某语言的这样一段代码，一直该语言支持嵌套函数

```
def func_1 (int a){
    int b = 2^a;
    def func_2 (){
        int c = b**2;
        /* here */
        ...
    }
}
```

我们在```func_2```中访问上级函数```func_1```中的局部变量```b```，这就叫做**嵌套过程/函数的非局部变量访问**。按照栈式的存储放分配，在执行到```/*here*/```的时候，栈中有```func_1```和```func_2```对应的活动记录，其中，```b```位于```func_1```的活动记录中，而当前栈顶的活动记录应该是```func_2```的。所以，为了支持嵌套过程/函数的非局部变量访问，我们需要为```func_1```和```func_2```建立联系。

通常的解决方法有：

- Display 表
- 静态链

我们下面主要介绍**静态链**的方式：

- 静态链（static link），也称访问链（access link），即在所有活动记录都增加一个域（增加在控制信息区里面），指向定义该过程的**直接外过程（或主程序）运行时最新的活动记录（的基址）**。

> 什么叫直接外过程？
> - 看代码，过程在代码层面的外面一层的过程叫做直接外过程
> 
> 而且是直接外过程的最新活动记录，即离栈顶最近的该直接外过程的活动记录。

与静态链对应的是动态链，虽然我们这里没有用到，但是还是要注意区分：

- 指向定义该过程的**外部调用过程的运行时最新的活动记录（的基址）**。

看这样一个例子：

```
def func_1 (int a){
    int b = 2^a;
    def func_2 (){
        int c = b**2;
        ...
    }
    def func_3 (){
        func_2() /* here */
    }
}
```

这里当执行到```/*here*/```进入```func_2```之后，对于```func_2```的活动记录，其静态链指向的是```func_1```的活动记录，而动态链指向的是```func_3```的活动记录。

### 嵌套程序块的非局部变量访问

来看某语言的一个例子：

```
int p{
    int A;
    {
        int B,C;
        ...
    }
    {
        int D,E,F;
        {
            int G;
            /*here*/
            ...
        }
    }
}
```

这里每个块内部都是自己的一个作用域，当执行到```/*here*/```的时候，不仅能访问当前块中的局部变量G，还能访问外层块中的变量D,E,F,A。这就叫做**嵌套程序块的非局部变量访问**。

通常的解决方法有：

- 把所有的块都看成一个无参无返回过程，然后用静态链的方式解决，但是这样会导致过多的过程调用，效率低下。
- 不为块单独开辟活动记录，而是直接在其所属的过程活动记录上采用覆写的方式

我们下面主要介绍**不为块单独开辟活动记录**的方式，以上面的例子来看：

<a href="https://sm.ms/image/8xlRpDFBdurnCi3" target="_blank"><img src="https://s2.loli.net/2022/12/18/8xlRpDFBdurnCi3.png" width=300></a>

> 注意上面这张图，FP到TOP之间是 p 过程的活动记录。

## 补充

教案中还补充了关于静态作用域、动态作用域以及函数调用过程的细节，可以一看。








